
MyCharacter.h
<code>
  #pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "GameFramework/SpringArmComponent.h" // Componente que maneja una distancia fija para la c�mara.
#include "Camera/CameraComponent.h" // Componente de c�mara para vistas en tercera persona.
#include "MyCharacter.generated.h"

UCLASS()
class TEMPLATEC_API AMyCharacter : public ACharacter
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AMyCharacter();

	//UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Collision")
	//UCapsuleComponent* CapsuleComponent;

	UPROPERTY(EditAnywhere, Category = "Components")
	TObjectPtr<USceneComponent> Root;

	//UPROPERTY(EditAnywhere, Category = "Components")
	//TObjectPtr<UArrowComponent> ArrowComponent;

	// Componente SpringArm: posiciona la c�mara a una distancia fija y permite que se ajuste autom�ticamente.
	UPROPERTY(EditAnywhere, Category = "Components")
	TObjectPtr<USpringArmComponent> SpringArmComp{ nullptr };

	// Componente de c�mara: proporciona la vista en tercera persona del personaje.
	UPROPERTY(EditAnywhere, Category = "Components")
	TObjectPtr<UCameraComponent> CameraComp{ nullptr };

	// Actor interactuable actual
	UPROPERTY(EditAnywhere, Category = "CurrentInteractableActor")
	//AActor* CurrentInteractableActor;
	TObjectPtr<AActor> CurrentInteractableActor;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	void Interactuar();
};
</code>


MyCharacter.cpp

<code>
  #include "MyCharacter.h"
#include <Components/CapsuleComponent.h>
#include "Components/SkeletalMeshComponent.h"
#include "UObject/ConstructorHelpers.h"
//#include "Components/ArrowComponent.h"
#include "Components/CapsuleComponent.h"

#include "Core/I_Interactuable.h"
#include "Animation/AnimInstance.h" // Necesario para trabajar con Animation Blueprints
#include "GameFramework/CharacterMovementComponent.h" // Maneja el movimiento del personaje.

// Sets default values
AMyCharacter::AMyCharacter()
{
 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

    // Configuraci�n del Skeletal Mesh
    static ConstructorHelpers::FObjectFinder<USkeletalMesh> DefaultMesh(TEXT("/Game/Characters/Mannequins/Meshes/SKM_Manny_Simple.SKM_Manny_Simple"));
    if (DefaultMesh.Succeeded())
    {
        UE_LOG(LogTemp, Warning, TEXT("Default SkeletalMesh Loaded Successfully!"));
        GetMesh()->SetSkeletalMesh(DefaultMesh.Object);
        GetMesh()->SetRelativeLocation(FVector(0.0f, 0.0f, -90.0f));
        GetMesh()->SetRelativeRotation(FRotator(0.0f, -90.0f, 0.0f));
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("Failed to Load Default SkeletalMesh!"));
    }

    // Configuraci�n del Animation Blueprint
    static ConstructorHelpers::FClassFinder<UAnimInstance> DefaultAnimBP(TEXT("/Game/Characters/Mannequins/Animations/ABP_Character"));
    if (DefaultAnimBP.Succeeded())
    {
        UE_LOG(LogTemp, Warning, TEXT("Default Animation Blueprint Loaded Successfully!"));
        GetMesh()->SetAnimationMode(EAnimationMode::AnimationBlueprint);
        GetMesh()->SetAnimInstanceClass(DefaultAnimBP.Class);
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("Failed to Load Animation Blueprint!"));
    }


    // Configuraci�n del movimiento del personaje
    GetCharacterMovement()->bOrientRotationToMovement = true; // Rotaci�n hacia la direcci�n del movimiento
    bUseControllerRotationYaw = false;
    bUseControllerRotationPitch = false;
    bUseControllerRotationRoll = false;

    // Crear el componente Arrow y agregarlo a la ra�z del personaje
    //ArrowComponent = CreateDefaultSubobject<UArrowComponent>(TEXT("ArrowComponent"));
    //ArrowComponent->SetupAttachment(RootComponent); // Lo agregamos al componente ra�z

    // Configuraci�n de la c�mara
    SpringArmComp = CreateDefaultSubobject<USpringArmComponent>(TEXT("SpringArmComp"));
    SpringArmComp->SetupAttachment(RootComponent);
    SpringArmComp->TargetArmLength = 300.0f;
    SpringArmComp->bUsePawnControlRotation = true;

    CameraComp = CreateDefaultSubobject<UCameraComponent>(TEXT("CameraComp"));
    CameraComp->SetupAttachment(SpringArmComp, USpringArmComponent::SocketName);

    // Accede al CapsuleComponent que ya viene con la clase ACharacter
    UCapsuleComponent* Capsule = GetCapsuleComponent();
    if (Capsule)
    {
        // Cambia el tama�o del radio y la altura del c�psula
        Capsule->InitCapsuleSize(42.0f, 96.0f);
        Capsule->SetCapsuleHalfHeight(100.f);
        Capsule->SetCollisionEnabled(ECollisionEnabled::QueryOnly); // Solo detecta colisiones, no bloquea
        Capsule->SetCollisionObjectType(ECC_WorldDynamic); // Tipo de objeto: din�mico
        Capsule->SetCollisionResponseToAllChannels(ECR_Ignore); // Ignorar todos los canales por defecto
        Capsule->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap); // Detectar solapamientos con personajes
        Capsule->SetCollisionResponseToChannel(ECC_WorldDynamic, ECR_Overlap); // Detectar actores interactuables
        Capsule->SetupAttachment(RootComponent);
        Capsule->SetGenerateOverlapEvents(true); // Asegurar que genera eventos de solapamiento

        // Configura las colisiones
        Capsule->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
        Capsule->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
        Capsule->SetCollisionObjectType(ECollisionChannel::ECC_Pawn);

        // Opcional: Cambia otros par�metros, como el canal de colisi�n o propiedades f�sicas
        Capsule->SetSimulatePhysics(false); // Si no quieres simulaci�n f�sica en el c�psula
    }
}

void AMyCharacter::BeginPlay()
{	Super::BeginPlay(); }

void AMyCharacter::Tick(float DeltaTime)
{	Super::Tick(DeltaTime); }

void AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{	Super::SetupPlayerInputComponent(PlayerInputComponent); }

// M�todo para realizar una interacci�n
void AMyCharacter::Interactuar()
{
    if (CurrentInteractableActor)
    {
        UE_LOG(LogTemp, Log, TEXT("Interactuando con: %s"), *CurrentInteractableActor->GetName());
        II_Interactuable::Execute_Interact(CurrentInteractableActor, this);
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("No hay ning�n actor interactuable."));
    }
}
</code>
